<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xml" href="http://localhost:4000//feed.xslt.xml"?><feed xmlns="http://www.w3.org/2005/Atom"><generator uri="http://jekyllrb.com" version="3.3.1">Jekyll</generator><link href="http://localhost:4000//feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000//" rel="alternate" type="text/html" /><updated>2017-12-03T22:50:46+08:00</updated><id>http://localhost:4000///</id><title type="html">Echo Young</title><subtitle>Echo Young's Blog.
</subtitle><entry><title type="html">JavaScript 风格指南（笔记）</title><link href="http://localhost:4000//2017/02/05/JavaScript-%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97-%E7%AC%94%E8%AE%B0.html" rel="alternate" type="text/html" title="JavaScript 风格指南（笔记）" /><published>2017-02-05T00:00:00+08:00</published><updated>2017-02-05T00:00:00+08:00</updated><id>http://localhost:4000//2017/02/05/JavaScript%20%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97(%E7%AC%94%E8%AE%B0)</id><content type="html" xml:base="http://localhost:4000//2017/02/05/JavaScript-%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97-%E7%AC%94%E8%AE%B0.html">&lt;h1 id=&quot;javascript-风格指南笔记&quot;&gt;JavaScript 风格指南（笔记）&lt;/h1&gt;

&lt;h2 id=&quot;变量&quot;&gt;变量&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;使用有意义、可读性好的变量名&lt;/li&gt;
  &lt;li&gt;使用 const 定义长俩个&lt;/li&gt;
  &lt;li&gt;对功能类似的变量名采用统一的命名风格&lt;/li&gt;
  &lt;li&gt;使用易于检索名称（特别是数字）&lt;/li&gt;
  &lt;li&gt;传递参数时，使用说明变量&lt;/li&gt;
  &lt;li&gt;不要绕太多的弯子，显式优于隐式&lt;/li&gt;
  &lt;li&gt;当类/对象名已有意义时，对其变量命名不需要再次重复&lt;/li&gt;
  &lt;li&gt;避免无意义的条件判断&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;函数&quot;&gt;函数&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;函数参数不超过 2 个&lt;/li&gt;
  &lt;li&gt;函数功能的单一性&lt;/li&gt;
  &lt;li&gt;函数命名明确功能&lt;/li&gt;
  &lt;li&gt;函数只做一层抽象&lt;/li&gt;
  &lt;li&gt;移出重复的代码&lt;/li&gt;
  &lt;li&gt;采用默认参数精简代码&lt;/li&gt;
  &lt;li&gt;使用 Object.assign 设置默认对象&lt;/li&gt;
  &lt;li&gt;不要使用标记（Flag） 作为函数参数&lt;/li&gt;
  &lt;li&gt;避免副作用，即避免「接受一个值并返回一个结果」&lt;/li&gt;
  &lt;li&gt;不要写全局函数&lt;/li&gt;
  &lt;li&gt;采用函数式编程&lt;/li&gt;
  &lt;li&gt;封装判断条件&lt;/li&gt;
  &lt;li&gt;避免「否定情况」的判断&lt;/li&gt;
  &lt;li&gt;避免条件判断，使用多态&lt;/li&gt;
  &lt;li&gt;避免类型判断&lt;/li&gt;
  &lt;li&gt;避免过度优化，现代浏览器运行时会对代码自动优化&lt;/li&gt;
  &lt;li&gt;删除无效代码&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;对象和数据结构&quot;&gt;对象和数据结构&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;使用 getters 和 setters&lt;/li&gt;
  &lt;li&gt;让对象拥有私有成员，可以通过闭包完成&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;类&quot;&gt;类&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;单一职责原则（SRP）&lt;/li&gt;
  &lt;li&gt;开/闭原则（OCP），易于扩展，难于修改&lt;/li&gt;
  &lt;li&gt;利斯科夫替代原则（LSP），子类对象应该能够替换其超类对象被使用&lt;/li&gt;
  &lt;li&gt;接口隔离原则（ISP），不依赖不需要的接口，一个类对另一个类的依赖应该建立在最小的接口上&lt;/li&gt;
  &lt;li&gt;依赖反转原则（DIP）&lt;/li&gt;
  &lt;li&gt;使用 ES6 的 classes 而不是 ES5 的 Function&lt;/li&gt;
  &lt;li&gt;使用方法链&lt;/li&gt;
  &lt;li&gt;优先使用组合模式而非继承&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;测试&quot;&gt;测试&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;单一的测试每个概念&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;并发&quot;&gt;并发&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;用 Promises 替代回调&lt;/li&gt;
  &lt;li&gt;Async/Await 是较 Promises 更好的选择&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;错误处理&quot;&gt;错误处理&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;捕获错误&lt;/li&gt;
  &lt;li&gt;不要忽略被拒绝的 promises&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;格式化&quot;&gt;格式化&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;大小写一致&lt;/li&gt;
  &lt;li&gt;调用函数的函数和被调函数应放在较近的位置&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;注释&quot;&gt;注释&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;只对存在一定业务逻辑复制性的代码进行注释&lt;/li&gt;
  &lt;li&gt;不要在代码库中遗留被注释掉的代码&lt;/li&gt;
  &lt;li&gt;不需要版本更新类型注释&lt;/li&gt;
  &lt;li&gt;避免位置标记&lt;/li&gt;
  &lt;li&gt;避免在源文件中写入法律评论&lt;/li&gt;
&lt;/ol&gt;</content><summary type="html">JavaScript 风格指南（笔记）</summary></entry><entry><title type="html">SVG 滤镜那些事儿</title><link href="http://localhost:4000//2016/12/01/SVG%E6%BB%A4%E9%95%9C%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF.html" rel="alternate" type="text/html" title="SVG 滤镜那些事儿" /><published>2016-12-01T00:00:00+08:00</published><updated>2016-12-01T00:00:00+08:00</updated><id>http://localhost:4000//2016/12/01/SVG%E6%BB%A4%E9%95%9C%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF</id><content type="html" xml:base="http://localhost:4000//2016/12/01/SVG%E6%BB%A4%E9%95%9C%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF.html">&lt;h1 id=&quot;svg-滤镜那些事儿&quot;&gt;SVG 滤镜那些事儿&lt;/h1&gt;

&lt;p&gt;虽然 SVG 不是一种位图描述语言，但它仍然允许我们使用一些相同的工具。当 SVG 阅读器程序处理一个图形对象时，它会将对象呈现在位图输出设备上；在某一时刻，阅读器程序会把对象的描述信息转换为一组对应的像素，然后呈现在输出设备上。&lt;/p&gt;

&lt;p&gt;SVG 滤镜的用法如下：&lt;/p&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;filter&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;f1&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;x=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;0%&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;y=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;-500%&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;width=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;1000%&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;height=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;1000%&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/filter&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;path&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;st1&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;style=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;filter:url(#f1)&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;stroke=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;url(#linear)&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;d=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;M-556,2050.5l123-52l53,8l32-14&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;用 SVG 的 &lt;filter&gt; 元素指定一组操作（也称作基元），在对象的旁边呈现一个模糊的投影，然后把这个滤镜附加给一个对象。&lt;/filter&gt;&lt;/p&gt;

&lt;p&gt;SVG 滤镜的用处在于可以创建投影效果。&lt;/p&gt;

&lt;h2 id=&quot;创建投影效果&quot;&gt;创建投影效果&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;投影 &lt;feGaussianBlur&gt;&lt;/feGaussianBlur&gt;&lt;/p&gt;

    &lt;p&gt;起始和结束 &lt;filter&gt; 标记之间就是执行操作的滤镜基元。每个基元有一个或多个输入，但只有一个输出。一个输入可以是原始图形（被指定为 SourceGraphic）、图形的阿尔法（不透明度）通道（被指定为 SourceAlpha），或者是前一个滤镜基元的输出。&lt;/filter&gt;&lt;/p&gt;

    &lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;filter&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;feGaussianBlur&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;in=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;sourceAlpha&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;stdDeviation=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;2&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/filter&amp;gt;&lt;/span&gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;指定输入源用 in 属性，用 stdDeviation 属性指定模糊度，数值越大，模糊度越大。如果给 stdDeviation 提供两个有空格分隔的数字，第一个数字表示 x 方向的模糊度，第二个数字表示 y 方向的模糊度。&lt;/p&gt;

    &lt;p&gt;滤镜返回的是模糊单元，而不是原始图形。要实现原始图形加上投影的效果，需要添加更多的滤镜单元。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;存储、链接、合并滤镜效果&lt;/p&gt;

    &lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;filter&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;f1&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;x=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;0%&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;y=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;-500%&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;width=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;1000%&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;height=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;1000%&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;  
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;feOffset&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;result=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;offOut&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;in=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;SourceGraphic&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;dx=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;5&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;dy=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;5&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;  
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;feGaussianBlur&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;result=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;blurOut&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;in=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;offOut&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;stdDeviation=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;8&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;  
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;feMerge&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;feMergeNode&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;in=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;blur&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;feMergeNode&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;in=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;SourceGraphic&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;	
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/feMerge&amp;gt;&lt;/span&gt;  
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/filter&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;feOffset&gt; 通过 dx 和 dy 指定偏移量。  

result 属性指定当前基元的结果稍后可以通过什么名字引用，它只在包含该基元的 &lt;filter&gt; 中有效。

&lt;feMerge&gt; 基元包裹一个 &lt;feMergeNode&gt; 元素列表，每个元素都制定一个输入，这些输入按照出现的顺序一个堆叠在另一个上面。

&lt;/feMergeNode&gt;&lt;/feMerge&gt;&lt;/filter&gt;&lt;/feOffset&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;发光式投影 &lt;feColorMatrix&gt;&lt;/feColorMatrix&gt;&lt;/p&gt;

    &lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;feColorMatrix&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;matrix&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;values=&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;0 0 0 0 0
0 0 0 0.9 0
0 0 0 0.9 0
0 0 0 1 0
&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;当黑色文本也需要投影时，可以用 &lt;feColorMatrix&gt; 来改变颜色值。当 type 属性为 matrix，必须设置 values 为 20 个数字，按照 4 行 5 列的格式来描述变换信息。这个矩阵可以看作：&lt;/feColorMatrix&gt;&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;values=
&quot;0 0 0 red 0
 0 0 0 green 0
 0 0 0 blue 0
 0 0 0 1 0&quot;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;关于矩阵的原理这里就不详细说明了。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;feImage&gt;

&lt;feImage&gt; 允许我们使用任意的 JPG、PNG、SVG 文件，或者带有 id 属性的 SVG 元素作为滤镜的输入源。

```html
&lt;feImage xlink:href=&quot;xx.jpg&quot; result=&quot;image&quot; x=&quot;0&quot; y=&quot;0&quot; width=&quot;100%&quot; height=&quot;100%&quot; preserveAspectRatio=&quot;none&quot; /&gt;
```

&lt;/feImage&gt;&lt;/feImage&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;feComposite&gt; 和 &lt;feBlend&gt;

除了 &lt;feMerge&gt; 合并滤镜，还可以通过 &lt;feComposite&gt; 和 &lt;feBlend&gt; 两种滤镜来进行合并。

两者都需要指定 in 和 in2 属性来接受两个输入源。

&lt;feComposite&gt; 通过 operator 属性来指定效果，可能值有：over、in、out、atop、xor、arithmetic 来改变两种滤镜的位置关系。

&lt;feBlend&gt; 通过 mode 属性设置如何混合输入源，可能值有：normal、multiply、screen、darken、lighten。


&lt;/feBlend&gt;&lt;/feComposite&gt;&lt;/feBlend&gt;&lt;/feComposite&gt;&lt;/feMerge&gt;&lt;/feBlend&gt;&lt;/feComposite&gt;
  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这些是目前接触到的滤镜，后续了解更多之后再做补充。&lt;/p&gt;</content><summary type="html">SVG 滤镜那些事儿</summary></entry><entry><title type="html">SVG 动画基础</title><link href="http://localhost:4000//2016/10/12/SVG%E5%8A%A8%E7%94%BB%E5%9F%BA%E7%A1%80.html" rel="alternate" type="text/html" title="SVG 动画基础" /><published>2016-10-12T00:00:00+08:00</published><updated>2016-10-12T00:00:00+08:00</updated><id>http://localhost:4000//2016/10/12/SVG%E5%8A%A8%E7%94%BB%E5%9F%BA%E7%A1%80</id><content type="html" xml:base="http://localhost:4000//2016/10/12/SVG%E5%8A%A8%E7%94%BB%E5%9F%BA%E7%A1%80.html">&lt;h1 id=&quot;svg-动画基础&quot;&gt;SVG 动画基础&lt;/h1&gt;

&lt;p&gt;用 SVG 做了两个动画的需求，写篇博客总结下。&lt;/p&gt;

&lt;p&gt;SVG，即可缩放矢量图形（Scaleable Vector Graphics），是一种 XML 应用，可以以一种简介、可移植的形式表示图形信息。写动画之前，需要准备素材，即 SVG 文件。有了素材则可以通过 CSS3 来呈现动画了。前端可以两种方法得到 SVG 文件，一种是通过将保留有&lt;strong&gt;绘制路径&lt;/strong&gt;的设计稿导出成 SVG 格式，然后可以通过 AI 得到 XML 代码；另一种方法则是自己编写代码绘制图形。将 SVG 代码内联到 HTML 中：&lt;/p&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;svg&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;viewBox=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;0 0 250 250&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;xmlns=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://www.w3.org/2000/svg&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
 &lt;span class=&quot;nt&quot;&gt;&amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/svg&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;基本图形&quot;&gt;基本图形&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;线段&lt;/p&gt;

    &lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;line&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;x1=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;start-x&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;y1=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;start-y&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;x2=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;end-x&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;y2=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;end-y&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;style=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;stroke-width: width; stroke: color;&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;除了上述属性之外，线段还有 stroke-opacity 控制线段的透明度，stroke-dasharray 控制线的长度和空隙的长度，数字之间用逗号或空格分隔，数字个数应为偶数，如果指定的数字个数为奇数，则 SVG 会重复一次，使得总个数为偶数。与 stroke-dasharray 对应的属性是 stroke-dashoffset，表示控制线的偏移量。stroke-dasharray 和 stroke-dashoffset 两个属性配合可以呈现出描边的过程。比如绘制一条 10px 的线段：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.line{
  stroke-dasharray: 10;
  stroke-dashoffset: 10;
  transition: all 1s linear;
}
.line.active{
  stroke-dashoffset: 0;
}
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;当偏移量从线段总长度逐渐减为 0 时，就是绘制出一条直线的过程。&lt;/p&gt;

    &lt;p&gt;​&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;矩形&lt;/p&gt;

    &lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;rect&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;x=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;50&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;y=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;10&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;width=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;20&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;height=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;40&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;&amp;lt;!-- 圆角矩形 --&amp;gt;&lt;/span&gt;  
&lt;span class=&quot;nt&quot;&gt;&amp;lt;rect&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;x=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;50&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;y=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;10&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;width=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;20&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;height=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;40&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;rx=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;10&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;ry=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;5&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;​&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;圆和椭圆&lt;/p&gt;

    &lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;&amp;lt;!-- 圆 --&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;circle&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;cx=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;30&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;cy=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;30&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;r=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;20&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;style=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;stroke-widith: 5; stroke: black; fill: none;&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;&amp;lt;!-- 椭圆 --&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;ellipse&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;cx=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;30&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;cy=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;80&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;rx=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;10&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;ry=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;20&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;style=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;stroke: black; fill: none;&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;​&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;多边形&lt;/p&gt;

    &lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;polygon&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;points=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;15,10 55,10 45,20 5,20&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;style=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;fill: red; stroke: black;&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;polygon&amp;gt;&lt;/code&gt; 元素可以用来画任意封闭图形，指定一系列的 x/y 坐标对，并用逗号或者空格分隔。&lt;/p&gt;

    &lt;p&gt;如果要填充边线交叉的多边形，fill-rule 属性有 nonzero 和 evenodd 两个值来呈现不同的填充效果。&lt;/p&gt;

    &lt;p&gt;​&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;折线&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;polyline&amp;gt;&lt;/code&gt; 与 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;polygon&amp;gt;&lt;/code&gt; 有相同的 points 属性，不同在于图形并不封闭。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;线帽和线连接&lt;/p&gt;

    &lt;p&gt;当使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;polyline&amp;gt;&lt;/code&gt; 与 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;polygon&amp;gt;&lt;/code&gt; 画线段时，可以用 stroke-linecap 指定不同的值来确定线的头尾形状，取值为 butt、round、square。也可以通过 stroke-linejoin 属性指定线段在棱角处交叉的效果，可能取值为 mitter（尖的）、round（圆的）、bevel（平的）。&lt;/p&gt;

    &lt;p&gt;​&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;分组和引用对象&quot;&gt;分组和引用对象&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;g&gt; 

&lt;g&gt; 元素会将其所有子元素作为一个组合，通常组合还有一个唯一的 id 作为名称。

&lt;/g&gt;&lt;/g&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;use&gt;

图形中经常会出现重复的元素，比如一个表盘上的刻度，秒针的刻度有 60 个，如果一个个画出来需要 60 个只有角度不一样的 &lt;line&gt; 或者 &lt;rect&gt;。这时我们可以只绘制一个刻度，然后通过复制粘贴绘制整个表盘，如下：

```
&lt;!--刻度--&gt;
&lt;rect id=&quot;secondMark&quot; x=&quot;-2&quot; y=&quot;-250&quot; width=&quot;2&quot; height=&quot;10&quot; /&gt;

&lt;g id=&quot;secondFace1&quot;&gt;
&lt;use xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot; xlink:href=&quot;#secondMark&quot; transform=&quot;rotate(06)&quot;&gt;&lt;/use&gt;
&lt;use xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot; xlink:href=&quot;#secondMark&quot; transform=&quot;rotate(12)&quot;&gt;&lt;/use&gt;
&lt;use xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot; xlink:href=&quot;#secondMark&quot; transform=&quot;rotate(18)&quot;&gt;&lt;/use&gt;
&lt;use xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot; xlink:href=&quot;#secondMark&quot; transform=&quot;rotate(24)&quot;&gt;&lt;/use&gt;
&lt;/g&gt;

&lt;g id=&quot;secondFace2&quot;&gt;
&lt;use xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot; xlink:href=&quot;#secondFace1&quot;&gt;&lt;/use&gt;
&lt;use xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot; xlink:href=&quot;#secondFace1&quot; transform=&quot;rotate(30)&quot;&gt;&lt;/use&gt;
&lt;use xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot; xlink:href=&quot;#secondFace1&quot; transform=&quot;rotate(60)&quot;&gt;&lt;/use&gt;
&lt;/g&gt;

&lt;g id=&quot;secondFace&quot;&gt;
&lt;use xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot; xlink:href=&quot;#secondFace2&quot;&gt;&lt;/use&gt;
&lt;use xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot; xlink:href=&quot;#secondFace2&quot; transform=&quot;rotate(90)&quot;&gt;&lt;/use&gt;
&lt;use xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot; xlink:href=&quot;#secondFace2&quot; transform=&quot;rotate(180)&quot;&gt;&lt;/use&gt;
&lt;use xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot; xlink:href=&quot;#secondFace2&quot; transform=&quot;rotate(270)&quot;&gt;&lt;/use&gt;
&lt;/g&gt;
```

定义了一组图形对象后，可以使用 &lt;use&gt; 标签再次显示它们。

​

&lt;/use&gt;&lt;/rect&gt;&lt;/line&gt;&lt;/use&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;defs&gt;

用于定义元素，但不显示它们，相当于作为”模板“供其他地方使用。

&lt;/defs&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;symbol&gt;

&lt;symbol&gt; 元素提供另一种组合元素的方式，和 &lt;g&gt; 不同的是，&lt;symbol&gt; 不会显示。&lt;symbol&gt; 可以指定 viewBox 和 preserveAspectRatio 属性，通过给 &lt;use&gt; 添加 width 和 height 属性就可以让 &lt;symbol&gt; 适配视口大小。

&lt;/symbol&gt;&lt;/use&gt;&lt;/symbol&gt;&lt;/symbol&gt;&lt;/g&gt;&lt;/symbol&gt;&lt;/symbol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;image&gt;

```
&lt;image xlink:href=&quot;xxx.jpg&quot; x=&quot;&quot; y=&quot;&quot; width=&quot;&quot; height=&quot;&quot;&gt;
```

如果图像文件的 尺寸与元素的宽度和高度不匹配，&lt;image&gt; 可以使用 preserveAspectRatio 属性指示浏览器怎么处理，默认值为 xMidYMid meet，会缩放图像并居中显示在指定的矩形中。

&lt;/image&gt;&lt;/image&gt;&lt;/image&gt;
  &lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;坐标系统变换&quot;&gt;坐标系统变换&lt;/h2&gt;

&lt;p&gt;我们可以给对应的 SVG 元素添加 transform 属性，来进行 translate 和 scale 变换，用法同 CSS3 一样。这里需要特别说明的是，translate 移动的不是图形对象，而是网格坐标。scale 不是改变图形队形的网格坐标或者笔画宽度，而是其对应画布上的坐标系统大小。因此，变换序列的顺序会形成不同的结果。&lt;/p&gt;

&lt;h2 id=&quot;渐变&quot;&gt;渐变&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;linearGradient 线性渐变&lt;/p&gt;

    &lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;linearGradient&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;two-hues&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;stop&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;offset=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;0%&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;style=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;stop-color: #ffcc00&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;stop&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;offset=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;100%&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;style=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;stop-color: #0099cc&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/linearGradient&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;rect&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;x=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;20&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;y=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;20&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;width=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;200&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;height=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;100&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;style=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;fill: url(#two-hues); stoke: black;&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;stop&gt; 元素有offset 和 stop-color 两个必要属性。offset 用于确定线上哪个点的颜色应该为 stop-color。

另外还可以使用 stop-capacity 设置颜色透明度。

```html
&lt;linearGradient x1=&quot;&quot; y1=&quot;&quot; x2=&quot;&quot; y2=&quot;&quot;&gt;&lt;/linearGradient&gt;
```

如果想要颜色沿着竖线或者有角度的线条过渡，就必须使用 x1 和 y1 以及 x2 和 y2 属性指定渐变的起点和终点。

&lt;/stop&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;radialGradient 径向渐变&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;radialGradient cx=&quot;0%&quot; cy=&quot;0%&quot; fx=&quot;50%&quot; fy=&quot;50%&quot; r=&quot;100%&quot;&amp;gt;&amp;lt;/radialGradient&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;cx 和 cy 指定渐变的起始位置，fx 和 fy 指定圆心位置，r 指定渐变圆心半径。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;demo-演示&quot;&gt;Demo 演示&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;http://codepen.io/echoyoung/pen/zKYYLR&quot;&gt;手表动画&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://codepen.io/echoyoung/pen/RGwNWN&quot;&gt;手机描边动画&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><summary type="html">SVG 动画基础</summary></entry><entry><title type="html">Three.js 入门和基础动画</title><link href="http://localhost:4000//2016/07/14/Three.js%E5%85%A5%E9%97%A8%E5%92%8C%E5%9F%BA%E7%A1%80%E5%8A%A8%E7%94%BB.html" rel="alternate" type="text/html" title="Three.js 入门和基础动画" /><published>2016-07-14T00:00:00+08:00</published><updated>2016-07-14T00:00:00+08:00</updated><id>http://localhost:4000//2016/07/14/Three.js%E5%85%A5%E9%97%A8%E5%92%8C%E5%9F%BA%E7%A1%80%E5%8A%A8%E7%94%BB</id><content type="html" xml:base="http://localhost:4000//2016/07/14/Three.js%E5%85%A5%E9%97%A8%E5%92%8C%E5%9F%BA%E7%A1%80%E5%8A%A8%E7%94%BB.html">&lt;h1 id=&quot;threejs入门和基础动画&quot;&gt;Three.js入门和基础动画&lt;/h1&gt;

&lt;p&gt;用Three.js绘制3D图形的步骤包括：定义场景、相机、渲染器、光线、物体。&lt;/p&gt;

&lt;p&gt;### 定义场景&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;var scene = new THREE.Scene();&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;scene相当于一个容器，用来包容我们想渲染的物体。&lt;/p&gt;

&lt;p&gt;### 定义相机&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;var camera = new THREE.PerspectiveCamera(fov, aspect, near, far);&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;fov表示视场，即相机位置所能看到的全部场景&lt;/li&gt;
  &lt;li&gt;aspect表示渲染结果输出去的长宽比，一般为window.innerWidth / window.innerHeight
    &lt;ul&gt;
      &lt;li&gt;near表示近面，定义的是距离相机多近的地方开始渲染场景&lt;/li&gt;
      &lt;li&gt;far表示远面，定义的是从近面出发可以看到多远的距离&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;camera.position.set(x, y, z); //设置相机位置&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;camera.lookAt(new THREE.Vector3(x,y,z)); //设置相机角度&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;### 定义渲染器&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;var webGLRenderer = new THREE.WebGLRenderer();&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;webGLRenderer.setClearColor(new THREE.Color(0x000, 1.0));&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;webGLRenderer.setSize(window.innerWidth, window.innerHeight);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;webGLRenderer.shadowMapEnabled = true;&lt;/code&gt; ​&lt;/p&gt;

&lt;p&gt;### 定义光源&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;var spotLight = new THREE.SpotLight(0xffffff); //设置光源颜色&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;spotLight.position.set(-20, 30, 40); //设置光源颜色&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;spotLight.intensity = 1.5 //设置光源亮度;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;光线包括：AmbientLight（环境光）、PointLight（点光源）、SpotLight（聚光灯光源）、DirectionalLight（方向光）、HemisphereLight（半球光）、AreaLight（面光源）、LensFlare（镜头眩光）。&lt;/p&gt;

&lt;h3 id=&quot;定义物体&quot;&gt;定义物体&lt;/h3&gt;

&lt;p&gt;Three.js提供了基本几何图形，包括二维和三维图形。&lt;/p&gt;

&lt;p&gt;创建几何体只需要：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;new THREE.PlaneGeometry(width, height, widthSegments, heightSegments);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;二维图形包括：PlaneGeometry（平面），CircleGeometry（平面圆）、ShapeGeometry（自定义二维图形）。&lt;/p&gt;

&lt;p&gt;三维图形包括：CubeGeometry（立方体）、SphereGeometry（球体）、CylinderGeometry（圆柱）、TotusGeometry（圆环）……&lt;/p&gt;

&lt;p&gt;如果是外部模型，则通过&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;loader.load(path, function(result){}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;加载到场景中。&lt;/p&gt;

&lt;p&gt;### 动画&lt;/p&gt;

&lt;p&gt;动画包括改变位置、缩放、旋转。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;obj.position.x=stepX; obj.position.y=stepY;obj.position.z=stepZ;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;obj.scale.set(scaleX, scaleY, scaleZ)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;obj.rotation.x = rotationX; obj.rotation.y = rotationY; obj.rotation.z = rotationZ;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;通过requestAnimatinoFrame来安排下一次渲染：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;requestAnimatinoFrame(render);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;如果要让几何体在垂直于Y轴的平面上沿着圆环运动，用sin、cos改变位置：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;obj.position.x = r*Math.cos(t);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;obj.position.z = r*Math.sin(t) - r;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;​&lt;/p&gt;</content><summary type="html">Three.js入门和基础动画</summary></entry><entry><title type="html">将 Excel 表格数据转化为 JSON</title><link href="http://localhost:4000//2016/03/05/%E5%B0%86Excel%E8%A1%A8%E6%A0%BC%E6%95%B0%E6%8D%AE%E8%BD%AC%E5%8C%96%E4%B8%BAJSON.html" rel="alternate" type="text/html" title="将 Excel 表格数据转化为 JSON" /><published>2016-03-05T00:00:00+08:00</published><updated>2016-03-05T00:00:00+08:00</updated><id>http://localhost:4000//2016/03/05/%E5%B0%86Excel%E8%A1%A8%E6%A0%BC%E6%95%B0%E6%8D%AE%E8%BD%AC%E5%8C%96%E4%B8%BAJSON</id><content type="html" xml:base="http://localhost:4000//2016/03/05/%E5%B0%86Excel%E8%A1%A8%E6%A0%BC%E6%95%B0%E6%8D%AE%E8%BD%AC%E5%8C%96%E4%B8%BAJSON.html">&lt;h1 id=&quot;将excel表格数据转化为json&quot;&gt;将Excel表格数据转化为JSON&lt;/h1&gt;

&lt;p&gt;本文介绍当产品给你一个表格，你要将表格里的数据以某种形式呈现到网页上时，不要傻傻地用手敲，用工具转换会比较方便。&lt;/p&gt;

&lt;p&gt;Mac环境下，用Numbers打开表格，表格第一行改为JSON数据中的key值，比如：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/6e453469gw1f423bxsvezj20j2018q2y.jpg&quot; alt=&quot;Numbers&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然后依次选择 File-&amp;gt;Export To-&amp;gt;CSV，将文件转化CSV格式。CSV文件是可以直接转化为JSON格式的，比如到 &lt;a href=&quot;http://www.csvjson.com/csv2json&quot;&gt;CSVJSON&lt;/a&gt; 站点，添加文件之后，选择根据逗号分隔数据，可以得到一串JSON直接使用。&lt;/p&gt;

&lt;p&gt;也可以再写段脚本转化为其他所需要的格式。&lt;/p&gt;</content><summary type="html">将Excel表格数据转化为JSON</summary></entry></feed>
